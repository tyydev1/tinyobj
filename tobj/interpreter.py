"""
The TinyObj Interpreter

This module contains the Interpreter class responsible for traversing the Abstract 
Syntax Tree (AST) generated by the parser and converting it into a standard 
Python dictionary structure, which typically represents a hierarchical data format 
like JSON or YAML.
"""

from typing import Dict, Any, List, Optional
# The following imports are assumed to exist in the TinyObj project structure
from tobj.errors import InterpreterError
from tobj.parser import ASTNode, ObjectNode, PropertyNode


class Interpreter:
    """
    Converts a list of Abstract Syntax Tree (AST) nodes into a nested Python 
    dictionary, following the object hierarchy defined in the TinyObj code.

    :param ast: The list of root-level AST nodes generated by the parser.
    :type ast: List[ASTNode]
    :ivar root: The resulting Python dictionary that stores the interpreted data structure.
    :vartype root: Dict[str, Any]
    :ivar current_object_path: The dot-separated path of the object currently being populated. Used to determine where properties belong.
    :vartype current_object_path: Optional[str]
    """

    def __init__(self, ast: List[ASTNode]) -> None:
        """
        Initializes the Interpreter with the parsed AST.

        :param ast: The list of AST nodes to process.
        :type ast: List[ASTNode]
        """
        self.ast: List[ASTNode] = ast
        self.root: Dict[str, Any] = {}
        self.current_object_path: Optional[str] = None

    def interpret(self) -> Dict[str, Any]:
        """
        Main method to traverse the AST and build the final dictionary.

        Iterates through the AST nodes and dispatches handling based on node type.

        :return: The fully constructed nested dictionary representing the interpreted TinyObj data.
        :rtype: Dict[str, Any]
        """
        for node in self.ast:
            if isinstance(node, ObjectNode):
                self.handle_object(node)
            elif isinstance(node, PropertyNode):
                self.handle_property(node)

        return self.root

    def handle_object(self, node: ObjectNode) -> None:
        """
        Handles an ObjectNode (*ObjectName).

        Sets the `current_object_path` and ensures that the corresponding 
        nested dictionary structure exists in the `root` dictionary.

        :param node: The ObjectNode to process.
        :type node: ObjectNode
        """
        self.current_object_path = node.path

        parts: List[str] = node.path.split('.')

        current: Dict = self.root
        for part in parts:
            if part not in current:
                current[part] = {}
            current = current[part]

    def handle_property(self, node: PropertyNode) -> None:
        """
        Handles a PropertyNode (>key value).

        Adds the key-value pair to the dictionary represented by the 
        `current_object_path`.

        :param node: The PropertyNode to process.
        :type node: PropertyNode
        :raises InterpreterError: If a property is encountered before any object has been defined (i.e., `current_object_path` is None).
        """
        if self.current_object_path is None:
            raise InterpreterError(
                node.pos_start,
                node.pos_end,
                "Property without object context. All properties must follow an object definition (*)."
            )

        parts: List[str] = self.current_object_path.split('.')
        current: Dict = self.root
        for part in parts:
            current = current[part]

        current[node.key] = node.value


def main():
    """
    Example usage of the Lexer, Parser, and Interpreter to process TinyObj code.
    """
    from tobj.lexer import Lexer
    from tobj.parser import Parser
    from tobj.interpreter import Interpreter
    import pprint
    import json

    tobj_code = """
*User
>name Alice
>age 30
>active true
>pet nothing

*User.profile
>bio "Hello World"
>score 9001

*User.tags
>favorites
- python
- rust
- C++
"""

    print("=== INPUT ===")
    print(tobj_code)

    lexer = Lexer(tobj_code)
    tokens = lexer.tokenize()

    parser = Parser(tokens)
    ast = parser.parse()

    print("\n=== AST ===")
    pprint.pprint(ast)

    interpreter = Interpreter(ast)
    result = interpreter.interpret()

    print("\n=== RESULT (Python dict) ===")
    pprint.pprint(result)

    print("\n=== RESULT (JSON) ===")
    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()